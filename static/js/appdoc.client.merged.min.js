"use strict";function _conds(){return setTimeout(PR.prettyPrint),React.createElement($FMD,null,React.createElement($h1,null,"Condiciones"),"Las reglas de condición if en Fluid CSS permiten crear estilos condicionales que se aplican en función del ancho de la pantalla. Estas reglas definen cómo deben cambiar las propiedades CSS a medida que el ancho de la ventana varía, permitiendo adaptar el diseño de la interfaz a diferentes tamaños de pantalla.",sep,React.createElement(MenorQue,null),sep,React.createElement(MayorQue,null),sep,React.createElement(Entre,null))}function MenorQue(){return React.createElement($index,{label:"Menor que (<)"},React.createElement($h4,null,"Menor que (<)"),React.createElement($CardF,null,"Esta condición se aplica cuando el ancho de la pantalla es menor que el valor especificado. Útil para definir estilos específicos cuando la interfaz debe adaptarse a pantallas más pequeñas.",React.createElement($CardDef,{title:"Menor que en X",elevation:0},"Esta regla define un punto de ajuste en el ancho de la pantalla donde se pueden aplicar estilos específicos. Permite establecer valores condicionales en función de si el ancho es menor que un valor límite (X). Esto facilita el diseño adaptativo en distintos dispositivos o tamaños de pantalla.",React.createElement($h,null),React.createElement("strong",null,React.createElement($secundario,null,"Estructura de interprete")),"Esta estructura permite definir condiciones directamente en el atributo code, lo cual es ideal para casos en los que se busca una implementación más directa o rápida sin tener que definir cada ajuste por separado.",React.createElement($h,null),React.createElement("strong",null,"Forma general"),React.createElement($$h,null),React.createElement($code,{style:{color:"khaki"}},["fluidCSS({","   code: `","      x<widthLimitpx?{","         attr-kebab-case: (true value, false value);","      }","   `,","   clss: 'cls-1 cls-2 ... extra-classes'","})"].join("\n")),React.createElement($$h,null),React.createElement("strong",null,"Ejemplo de uso"),React.createElement($$h,null),React.createElement($PR,{lang:"javascript"},["fluidCSS({","   code: `","      x<900px?{","         background-color: (red, blue);","      }","   `,","   clss: 'cls-1 cls-2 extra-classes'","})"].join("\n")),React.createElement($$h,null),React.createElement("strong",null,React.createElement($secundario,null,"Estructura cascada")),"La estructura en cascada permite crear una cadena de ajustes más organizada, en la que cada condición se aplica en una línea y se evalúa en función del valor de widthPxLimit. Esto facilita la legibilidad y hace que sea más sencillo añadir o modificar condiciones según se necesite.",React.createElement($h,null),React.createElement("strong",null,"Forma general"),React.createElement($$h,null),React.createElement($code,{style:{color:"khaki"}},["fluidCSS()","   .ltX(widthPxLimit, {","      attrCamelCase: ['true-value', 'false-value' ]","   })","   .end(...extraClasses);"].join("\n")),React.createElement($$h,null),React.createElement("strong",null,"Ejemplo de uso"),React.createElement($$h,null),React.createElement($PR,{lang:"javascript"},["fluidCSS()","   .ltX(900, {","      backgroundColor: ['red', 'blue' ]","   })","   .end('cls-1 cls-2 extra-classes');"].join("\n"))),React.createElement($CardF,{elevation:6,className:"pad-10px"},"La condición ltY en **fluidCSS** permite aplicar estilos específicos cuando la altura de la pantalla es menor que un valor determinado, lo cual es ideal para adaptarse a pantallas más pequeñas o en modo horizontal en dispositivos móviles.",React.createElement("p",null,"Esto permite que el diseño se ajuste automáticamente para mejorar la experiencia visual en espacios reducidos, adaptando elementos como el tamaño de texto, el margen y otros estilos según el espacio disponible."))))}function MayorQue(){return React.createElement($index,{label:"Mayor que (>)"},React.createElement($h4,null,"Mayor que (>)"),React.createElement($CardF,null,"Esta condición se aplica cuando el ancho de la pantalla es mayor que el valor especificado. Es ideal para definir estilos específicos en pantallas grandes, permitiendo que la interfaz aproveche el espacio adicional de dispositivos con mayor resolución.",React.createElement($CardDef,{title:"Mayor que en X",elevation:0},'La regla de "mayor que" establece un punto de ajuste en el que se aplican estilos específicos cuando el ancho de la pantalla supera un valor límite (X). Esto permite configurar diseños que se adaptan y enriquecen en pantallas más amplias, optimizando la experiencia de usuario para dispositivos de escritorio o grandes formatos.',React.createElement($h,null),React.createElement("strong",null,React.createElement($secundario,null,"Estructura de interprete")),"Esta estructura permite definir condiciones directamente en el atributo code, lo cual es ideal para casos en los que se busca una implementación directa y rápida, sin necesidad de configurar cada ajuste por separado.",React.createElement($h,null),React.createElement("strong",null,"Forma general"),React.createElement($$h,null),React.createElement($code,{style:{color:"khaki"}},["fluidCSS({","   code: `","      x>widthLimitpx?{","         attr-kebab-case: (true value, false value);","      }","   `,","   clss: 'cls-1 cls-2 ... extra-classes'","})"].join("\n")),React.createElement($$h,null),React.createElement("strong",null,"Ejemplo de uso"),React.createElement($$h,null),React.createElement($PR,{lang:"javascript"},["fluidCSS({","   code: `","      x>1200px?{","         font-size: (18px, 14px);","      }","   `,","   clss: 'cls-1 cls-2 extra-classes'","})"].join("\n")),React.createElement($$h,null),"En este ejemplo, la condición x>1200px establece que, si el ancho de la pantalla es mayor a 1200 píxeles, el tamaño de la fuente (font-size) será de 18px. de lo contrario, el tamaño de la fuente será de 14px. La propiedad clss permite añadir clases adicionales que se ajustarán según la condición.",React.createElement($$h,null),React.createElement("strong",null,React.createElement($secundario,null,"Estructura cascada")),"La estructura en cascada permite organizar ajustes en una secuencia fácil de leer y entender. Cada condición se aplica en una línea y se evalúa según el valor de widthPxLimit, facilitando la adición o modificación de condiciones según sea necesario.",React.createElement($h,null),React.createElement("strong",null,"Forma general"),React.createElement($code,{style:{color:"khaki"}},["fluidCSS()","   .gtX(widthPxLimit, {","      attrCamelCase: ['true-value', 'false-value' ]","   })","   .end(...extraClasses);"].join("\n")),React.createElement($$h,null),React.createElement("strong",null,"Ejemplo de uso"),React.createElement($PR,{lang:"javascript"},["fluidCSS()","   .gtX(1200, {","      fontSize: ['18px', '14px' ]","   })","   .end('cls-1 cls-2 extra-classes');"].join("\n")),React.createElement($$h,null),"En este caso, gtX(1200) evalúa si el ancho de la pantalla es mayor a 1200 píxeles. Si es así, el tamaño de la fuente (fontSize) será de 18px. De lo contrario, será de 14px. La función .end permite especificar clases adicionales que se aplicarán en ambos casos, facilitando la configuración visual."),React.createElement(Card,{elevation:6,className:"pad-10px"},"La condición gtY en fluidCSS permite aplicar estilos distintos cuando la pantalla es más alta que un valor específico, ideal para adaptarse a dispositivos móviles en modo vertical.",React.createElement("p",null,"Con una estructura simple, puedes definir cambios en el diseño según la altura disponible, logrando una adaptación visual más cómoda y personalizada."))))}function Entre(){return React.createElement($index,{label:"Entre (<<)"},React.createElement($h4,null,"Entre (<<)"),React.createElement($CardF,null,"La condición Entre en fluidCSS permite aplicar estilos cuando el ancho o la altura de la pantalla están dentro de un rango específico. Es útil para ajustar el diseño en dispositivos con pantallas de tamaños intermedios, como tabletas o ventanas redimensionadas.",React.createElement("p",null,"Además de la estructura básica bifurcada, que evalúa dos condiciones (por debajo y por encima de un valor límite), también se puede utilizar la forma trifurcada, que agrega una condición intermedia para definir estilos más específicos en tres rangos de tamaño."),React.createElement($CardDef,{title:"Forma General (Bifurcada)",elevation:0},React.createElement($$h,null),"La **forma general bifurcada** en `fluidCSS` permite definir reglas que aplican estilos específicos cuando el ancho o la altura de la pantalla está dentro de un rango determinado.",React.createElement("p",null,"Se utiliza una sintaxis simple que permite indicar qué estilos se deben aplicar cuando la pantalla está dentro del rango de tamaños y qué estilos aplicar cuando está fuera de ese rango. Esto facilita la creación de diseños que se adaptan a diferentes tamaños de pantalla, sin tener que escribir reglas complejas o separadas."),React.createElement("strong",null,React.createElement($secundario,null,"Estructura de interprete")),React.createElement($h,null),React.createElement("strong",null,"Forma general"),React.createElement($code,{style:{color:"khaki"}},["fluidCSS({","   code: `","      widthBelowLimitpx<x<widthAboveLimitpx?{","         attr-kebab-case: (true value, false value);","      }","   `,","   clss: 'cls-1 cls-2 ... extra-classes'","})"].join("\n")),React.createElement($$h,null),React.createElement("strong",null,"Ejemplo de uso"),React.createElement($PR,{lang:"javascript"},["fluidCSS({","   code: `","      600px<x<1200px?{","         font-size: (16px, 12px);","      }","   `,","   clss: 'cls-1 cls-2 extra-classes'","})"].join("\n")),React.createElement($$h,null),"En este ejemplo, la condición 600px<x<1200px establece que si el ancho de la pantalla está entre 600 y 1200 píxeles, el tamaño de la fuente será de 16px. Si el ancho está fuera de ese rango (es menor a 600 píxeles o mayor a 1200 píxeles), el tamaño de la fuente será de 12px. La propiedad clss permite añadir clases adicionales que se aplicarán según la condición.",React.createElement($$h,null),React.createElement("strong",null,React.createElement($secundario,null,"Estructura cascada")),"La estructura en cascada también permite aplicar estas condiciones de manera sencilla y organizada, tanto para casos bifurcados como trifurcados, en una secuencia que mejora la legibilidad y la organización del código.",React.createElement($h,null),React.createElement("strong",null,"Forma general"),React.createElement($code,{style:{color:"khaki"}},["fluidCSS()","   .btwX([minWidthPxLimit, maxWidthPxLimit], {","      attrCamelCase: 'true-value'","   })","   .end(...extraClasses);","","fluidCSS()","   .btwX([minWidthPxLimit, maxWidthPxLimit], {","      attrCamelCase: ['true-value', 'false-value' ]","   })","   .end(...extraClasses);","","fluidCSS()","   .btwX([minWidthPxLimit, maxWidthPxLimit], {","      attrCamelCase: ['below-value', 'btw-value', 'above-value']","   })","   .end(...extraClasses);"].join("\n")),React.createElement($$h,null),React.createElement("strong",null,"Ejemplo de uso"),React.createElement($PR,{lang:"javascript"},["fluidCSS()","   .btwX([600, 1200], {","      fontSize: '16px'","   })","   .end('cls-1 cls-2 extra-classes');","","fluidCSS()","   .btwX([600, 1200], {","      fontSize: ['16px', '12px' ]","   })","   .end('cls-1 cls-2 extra-classes');","","fluidCSS()","   .btwX([600, 1200], {","      fontSize: ['12px', '16px', '20px']","   })","   .end('cls-1 cls-2 extra-classes');",""].join("\n"))),React.createElement(Card,{elevation:6,className:"pad-10px"},"La condición btwY en fluidCSS funciona de manera similar a btwX, pero en lugar de basarse en el ancho de la pantalla, se aplica en función de la altura.",React.createElement("p",null,"Esta condición permite definir estilos cuando la altura de la pantalla está dentro de un rango específico, lo cual es útil para ajustar el diseño en dispositivos con pantallas verticales o cuando la altura de la ventana cambia, como en el caso de la rotación de dispositivos móviles."),"Al igual que en btwX, se puede usar tanto en forma bifurcada (con dos valores: dentro y fuera del rango) como en forma trifurcada (con tres valores: por debajo, dentro y por encima del rango).")))}function initApp(){Object.assign(config_template,{banner:{left:{label:"Documentación",logo:"static/img/icon.svg"},right:{social:{github:{label:"Jeff-Aporta",url:"https://github.com/Jeff-Aporta"},youtube:{label:"YouTube",url:"https://www.youtube.com/@JeffAporta"},whatsapp:{label:"WhatsApp",url:"https://wa.link/1tmqmt"},telegram:{label:"Telegram",url:"https://t.me/jeffAporta"}}}},mapSite:[{lbl:" "},{component:function(){return React.createElement(_masEnMiPortafolio,null)}},{lbl:" - "},{lbl:"Empecemos"},{lbl:"Introducción",id:"intro",content:function(){return React.createElement(_intro,null)},i:"fa-regular fa-file-lines"},{lbl:" "},{lbl:"Uso"},{lbl:"Condiciones",id:"conds",content:function(){return React.createElement(_conds,null)},i:"fa-solid fa-person-chalkboard"},{lbl:"Interpolación líneal",id:"lerp",content:function(){return React.createElement(_lerp,null)},i:"fa-solid fa-arrows-left-right"},{lbl:"  "}],repo:{name:"Fluid CSS",url:"https://github.com/Jeff-Aporta/fluid-css"}}),ReactDOM.render(React.createElement(App,null),document.getElementById("root")),changeContent({id:get_id_param()})}var sep=React.createElement(_,null,React.createElement($$h,null),React.createElement($hr,null),React.createElement($$h,null));function _intro(){return React.createElement($FMD,null,React.createElement(_$Bienvenido,{name_app:"Fluid CSS",img_url:"static/img/app.svg"},"Sistema avanzado de manejo y manipulación de estilos CSS dinámicos, basado en comandos personalizados.",React.createElement("p",null,"Diseñado para ajustar y personalizar estilos en función de condiciones específicas, Fluid CSS permite definir reglas CSS que responden a parámetros como el tamaño de la pantalla, mediante comandos de estilo encapsulados.")),React.createElement($$h,null),React.createElement($hr,null),React.createElement($$h,null),React.createElement(Card,{className:"pad-10px"},React.createElement($,{variant:"h8"},React.createElement($secundario,null,"Características principales:")),React.createElement($CardDef,{title:"Interpolación Lineal",elevation:0},"ajusta de manera fluida los atributos que utilicen unidades en píxeles, permitiendo que los elementos de la interfaz se adapten proporcionalmente. Los diseños responsivos harán transiciones suaves y escalado preciso."),React.createElement($CardDef,{title:"Condiciones Dinámicas",elevation:0},'Define comportamientos específicos mediante condiciones dinámicas como "menor que", "mayor que" y "entre", aplicadas al ancho o a la altura de la ventana.',React.createElement("p",null,"Ajusta de manera fluida los elementos que respondan a diferentes propiedades en rangos de dimensiones, optimizando la adaptación de la interfaz según el tamaño de la pantalla.")),React.createElement($CardDef,{title:"Fácil Integración",elevation:0},"Compatible con cualquier proyecto web y es sencillo de implementar. Funciona tanto en el lado del cliente como en el lado del servidor usando npm, lo que permite una integración flexible y adaptable a distintos entornos de desarrollo.",React.createElement("p",null,"Ideal para la adaptación dinámica de los estilos según las dimensiones de la ventana, optimizando la experiencia visual sin complicaciones adicionales."))),React.createElement($$h,null),React.createElement(Card,{className:"pad-20px",elevation:6},React.createElement("strong",null,"Fluid CSS es ideal para proyectos que necesitan adaptarse de manera elegante y responsiva a diferentes dispositivos y resoluciones.")),React.createElement($$h,null),React.createElement($hr,null),React.createElement($$h,null),React.createElement(_$Instalación,{url_cdn:"https://jeff-aporta.github.io/fluid-css/static/js/index.all.min.js",npm_pack:"fluid-css-lng"}))}function _lerp(){return setTimeout(PR.prettyPrint),React.createElement($FMD,null,React.createElement($h1,null,"Interpolación líneal"),"Las reglas LERP (Linear Interpolation) en Fluid CSS permiten crear transiciones suaves entre diferentes valores de propiedades CSS en función del tamaño de la pantalla. Utilizando interpolación lineal, estas reglas definen cómo deben cambiar las propiedades a medida que el ancho de la ventana se expande o se contrae dentro de un rango específico, proporcionando una transición fluida y precisa.",sep,React.createElement(a,null),sep,React.createElement(e,null),sep,React.createElement(n,null),sep,React.createElement(c,null),sep,React.createElement(l,null),sep,React.createElement(t,null),sep,React.createElement($index,{label:"A nivel de CSS"},React.createElement($h3,null,"Funcionamiento a nivel de CSS"),React.createElement($$h,null),React.createElement($CardF,null,"Las reglas lerp funcionan a nivel de CSS, es decir, JavaScript, aunque interpreta las reglas, no tiene que realizar cálculos más allá de la interpretación de las mismas.",React.createElement("p",null,"Existen ecuaciones sobre las que se basa la interpolación lineal. La ecuación es la siguiente:"),React.createElement($code,{style:{color:"khaki"},elevation:0},"v_lerp = (vf - vi) * t + vi"),"A continuación, se muestra una guía de cómo se realiza la interpolación lineal en CSS.",React.createElement($PR,{lang:"css",elevation:0},loadStringsSync("static/jsx/frags/lerp-css.txt")),"Debido a cómo se aprovecha CSS para realizar la interpolación lineal, la regla lerp solo se puede aplicar a propiedades de medidas en px y no se puede aplicar a propiedades como color, background, opacity, etc.")));function e(){return React.createElement($index,{label:"Tipos de proyección"},React.createElement($h3,null,"Tipos de proyección"),React.createElement($$h,null),React.createElement($CardF,null,"En las reglas LERP, los corchetes `[ ]` y los paréntesis `( )` tienen significados específicos que permiten controlar cómo se comportan las interpolaciones a lo largo del rango de anchos de pantalla definido.",React.createElement($CardDef,{title:"Proyección abierta ( )",elevation:0},"Indica que la interpolación continuará siendo lineal más allá de los límites del rango de anchos de pantalla."),React.createElement($CardDef,{title:"Proyección cerrada [ ]",elevation:0},"Indica que la interpolación conservará el valor del extremo más cercano al rango de anchos de pantalla."),React.createElement($CardDef,{title:"Proyección mixta ( ] o [ )",elevation:0},"Indica que la interpolación conservará el valor del extremo más cercano al rango de anchos de pantalla.")))}function a(){return React.createElement($index,{label:"Sintaxis"},React.createElement($h3,null,"Sintaxis"),React.createElement(Card,{className:"pad-10px"},React.createElement("p",null,"La estructura básica de una regla ",React.createElement("b",null,"LERP")," es la siguiente:"),React.createElement($code,{style:{color:"khaki"},elevation:0},["minWidth<-x->maxWidth?{","   attr-kebab-case: (valueInitialpx, valueFinalpx); ","}"].join("\n")),React.createElement("p",null,React.createElement("b",null,"Ejemplo.")),React.createElement($PR,{lang:"javascript",elevation:0},["fluidCSS({","   code: `","      600px<-x->1200px?{","         font-size: (16px, 24px);","     }","   `,","   clss: 'extra-classes'","});"].join("\n"))))}function t(){return React.createElement($index,{label:"Modo Cascada"},React.createElement($h3,null,"Modo Cascada"),React.createElement($$h,null),React.createElement($CardF,null,"En el contexto de fluidCSS, el método lerpX permite realizar interpolaciones lineales de manera fluida entre dos valores a lo largo de un rango específico. La sintaxis básica es la siguiente:",React.createElement($$h,null),React.createElement($PR,{lang:"javascript",style:{color:"khaki"},elevation:0},React.createElement("pre",null,React.createElement("code",null,["fluidCSS().lerpX([initLimit, finLimit],{","   attrCamelCase: [initValue, finValue] // Close projection","})","","fluidCSS().lerpX([initLimit, finLimit],{","   attrCamelCase: [flagInit, initValue, finValue] // Mix projection with only flag init","})","","fluidCSS().lerpX([initLimit, finLimit],{","   attrCamelCase: [flagInit, initValue, finValue, flagFinal] // Mix projection with flags","})","","fluidCSS().lerpX([initLimit, finLimit],{","   attrCamelCase: ['o', initValue, finValue, 'o'] // Open projection","})"].join("\n")))),React.createElement($$h,null),React.createElement($PR,{lang:"javascript",elevation:0},["fluidCSS().lerpX([600,1200],{","   margin: [20, 50] // Proyección cerrada por defecto","})"].join("\n")),React.createElement($$h,null),"Esta regla realiza una interpolación cerrada por defecto, es decir, si el ancho de la pantalla está fuera del rango definido (menor a 600px o mayor a 1200px), el valor de la propiedad margin se mantendrá constante en el extremo más cercano.",React.createElement("strong",null,'Bandera "e" (End) y "o" (Open)'),'Las banderas "e" (end) y "o" (open) permiten controlar cómo se comporta la interpolación en los extremos del rango:',React.createElement("p",null,'Proyección abierta ("o"): Para hacer que la interpolación continúe más allá de los límites del rango de anchos de pantalla, puedes usar las banderas "o" al inicio o al final del rango. Ejemplo de proyección abierta:'),React.createElement($PR,{lang:"javascript",elevation:0},["fluidCSS().lerpX([600,1200],{","   margin: ['o', 20, 50, 'o'] // Proyección abierta","})"].join("\n")),React.createElement($h,null),"En este caso, la interpolación continuará más allá de los 600px y 1200px, y los valores se calcularán de forma lineal fuera de este rango.",React.createElement("p",null,React.createElement("b",null,"La proyección mixta ( ]"),' se utiliza para tener una interpolación abierta al principio y cerrada al final. Aquí, puedes usar "o" al inicio y "e" al final, o solo "o" al principio: Ejemplo de proyección mixta ( ]:'),React.createElement($PR,{lang:"javascript",elevation:0},["fluidCSS().lerpX([600,1200],{","   margin: ['o', 20, 50] // Proyección mixta ( ]","   // Lo mismo que:","   margin: ['o', 20, 50, 'e'] // Proyección mixta ( ]","})"].join("\n")),React.createElement($$h,null),"En este caso, la interpolación será cerrada a la izquierda (por debajo de 600px) y abierta a la derecha (por encima de 1200px).",React.createElement("p",null,React.createElement("b",null,"Proyección mixta [ ):"),' La proyección mixta [ ) se utiliza cuando se quiere que la interpolación se comporte como cerrada en un extremo (izquierda) y abierta en el otro (derecha). Para lograr esto, usas la bandera "e" al inicio y "o" al final o solo una de ellas.'),React.createElement($PR,{lang:"javascript",elevation:0},["fluidCSS().lerpX([600,1200],{","   margin: ['e', 20, 50, 'o'] // Proyección mixta [ )","})"].join("\n")),React.createElement($$h,null),"Esto indica que la interpolación será abierta al inicio (antes de 600px) y cerrada al final (después de 1200px)."))}function l(){return React.createElement($index,{label:"Proyección mixta ( ] o [ )"},React.createElement($h3,null,"Proyección mixta ( ] o [ )"),React.createElement($$h,null),React.createElement($CardF,null,"Los corchetes `[ ]` y los paréntesis `( )` pueden generar una proyección mixta.",React.createElement("p",null,"Una proyección mixta significa que la interpolación se comportará de manera diferente en cada extremo, siendo uno de los lados abierto y el otro cerrado."),React.createElement("strong",null,"Sintáxis"),React.createElement($$h,null),React.createElement($code,{style:{color:"khaki"},elevation:0},["600px<-x->1200px?{","   margin: [20px, 50px);","}"].join("\n")),React.createElement("center",null,React.createElement(a,null)),React.createElement($$h,null),"Significa que la interpolación se hará desde 600px con margen de 20px hasta 1200px con margen de 50px. La proyección mixta `[ )` implica que cuando el ancho de la pantalla sea menor a 600px, la interpolación se comportará como cerrada `(manteniendo el valor 20px)`, y cuando el ancho sea mayor a 1200px, la interpolación será abierta, superando la proyección del valor 50px.",React.createElement($$h,null),React.createElement($code,{style:{color:"khaki"},elevation:0},["600px<-x->1200px?{","   margin: (20px, 50px];","}"].join("\n")),React.createElement("center",null,React.createElement(e,null)),React.createElement($$h,null),"En este caso, la interpolación se realiza desde 600px con margen de 20px hasta 1200px con margen de 50px. La proyección mixta `( ]` significa que cuando el ancho de la pantalla sea menor a 600px, la interpolación será abierta (continuará calculando los valores de manera lineal), y cuando el ancho sea mayor a 1200px, la interpolación se comportará como cerrada (manteniendo el valor 50px)."),React.createElement($$h,null),React.createElement($CardF,{elevation:6},"Este tipo de proyección es útil cuando se desea que los valores de las propiedades CSS no pasen de los límites establecidos, manteniendo un comportamiento controlado dentro del rango definido."));function e(){return React.createElement("svg",{width:"350",height:"300",xmlns:"http://www.w3.org/2000/svg",style:{backgroundColor:"white",margin:"20px",filter:"invert(0.95)",borderRadius:"20px"}},React.createElement("g",{transform:"translate(40, 260)"},React.createElement("line",{x1:"-350",y1:"0",x2:"350",y2:"0",stroke:"black",strokeWidth:"2"}),React.createElement("line",{x1:"0",y1:"-300",x2:"0",y2:"300",stroke:"black",strokeWidth:"2"}),React.createElement("line",{x1:"20%",y1:"-300",x2:"20%",y2:"300",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"70%",y1:"-300",x2:"70%",y2:"300",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"-350",y1:"-20%",x2:"350",y2:"-20%",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"-350",y1:"-70%",x2:"350",y2:"-70%",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"20%",y1:"-20%",x2:"70%",y2:"-70%",stroke:"red",strokeWidth:"3"}),React.createElement("line",{x1:"70%",y1:"-70%",x2:"350",y2:"-70%",stroke:"magenta",strokeWidth:"3"}),React.createElement("line",{x1:"20%",y1:"-20%",x2:"-100%",y2:"100%",stroke:"magenta",strokeWidth:"3"}),React.createElement("text",{x:"20%",y:"20",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"600px"),React.createElement("text",{x:"70%",y:"20",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"1200px"),React.createElement("text",{x:"-20",y:"-20%",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"20px"),React.createElement("text",{x:"-20",y:"-70%",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"50px")))}function a(){return React.createElement("svg",{width:"350",height:"300",xmlns:"http://www.w3.org/2000/svg",style:{backgroundColor:"white",margin:"20px",filter:"invert(0.95)",borderRadius:"20px"}},React.createElement("g",{transform:"translate(40, 260)"},React.createElement("line",{x1:"-350",y1:"0",x2:"350",y2:"0",stroke:"black",strokeWidth:"2"}),React.createElement("line",{x1:"0",y1:"-300",x2:"0",y2:"300",stroke:"black",strokeWidth:"2"}),React.createElement("line",{x1:"20%",y1:"-300",x2:"20%",y2:"300",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"70%",y1:"-300",x2:"70%",y2:"300",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"-350",y1:"-20%",x2:"350",y2:"-20%",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"-350",y1:"-70%",x2:"350",y2:"-70%",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"20%",y1:"-20%",x2:"70%",y2:"-70%",stroke:"red",strokeWidth:"3"}),React.createElement("line",{x1:"-350",y1:"-20%",x2:"20%",y2:"-20%",stroke:"magenta",strokeWidth:"3"}),React.createElement("line",{x1:"100%",y1:"-100%",x2:"70%",y2:"-70%",stroke:"magenta",strokeWidth:"3"}),React.createElement("text",{x:"20%",y:"20",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"600px"),React.createElement("text",{x:"70%",y:"20",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"1200px"),React.createElement("text",{x:"-20",y:"-20%",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"20px"),React.createElement("text",{x:"-20",y:"-70%",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"50px")))}}function n(){return React.createElement($index,{label:"Proyección abierta ( )"},React.createElement($h3,null,"Proyección abierta ( )"),React.createElement($$h,null),React.createElement($CardF,null,"La proyección abierta, representada por paréntesis `()`, permite que los valores de un diseño continúen ajustándose incluso fuera del rango de condiciones especificadas.",React.createElement("p",null,"En otras palabras, si el tamaño de la pantalla supera o queda por debajo de los límites establecidos, la interpolación de los estilos sigue calculándose de manera lineal, extendiendo el ajuste más allá de esos límites."),React.createElement("p",null,"Esto es útil cuando se desea que los estilos cambien de forma continua sin detenerse, asegurando una transición fluida sin importar si la pantalla es más pequeña o más grande que el rango definido."),React.createElement("strong",null,"Sintáxis"),React.createElement($h,null),React.createElement($code,{style:{color:"khaki"},elevation:0},["600px<-x->1200px?{","   margin: (20px, 50px);","}"].join("\n")),React.createElement("center",null,React.createElement(e,null)),React.createElement($$h,null),"En el ejemplo, el hecho de que la proyección sea abierta implica que, aunque el ancho de la pantalla sea menor de 600px o mayor de 1200px, la interpolación seguirá calculando y proyectando los valores de la propiedad linealmente, extendiendo la transición fuera del rango definido."));function e(){return React.createElement("svg",{width:"350",height:"300",xmlns:"http://www.w3.org/2000/svg",style:{backgroundColor:"white",margin:"20px",filter:"invert(0.95)",borderRadius:"20px"}},React.createElement("g",{transform:"translate(40, 260)"},React.createElement("line",{x1:"-350",y1:"0",x2:"350",y2:"0",stroke:"black",strokeWidth:"2"}),React.createElement("line",{x1:"0",y1:"-300",x2:"0",y2:"300",stroke:"black",strokeWidth:"2"}),React.createElement("line",{x1:"20%",y1:"-300",x2:"20%",y2:"300",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"70%",y1:"-300",x2:"70%",y2:"300",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"-350",y1:"-20%",x2:"350",y2:"-20%",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"-350",y1:"-70%",x2:"350",y2:"-70%",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"20%",y1:"-20%",x2:"70%",y2:"-70%",stroke:"red",strokeWidth:"3"}),React.createElement("line",{x1:"20%",y1:"-20%",x2:"-100%",y2:"100%",stroke:"magenta",strokeWidth:"3"}),React.createElement("line",{x1:"100%",y1:"-100%",x2:"70%",y2:"-70%",stroke:"magenta",strokeWidth:"3"}),React.createElement("text",{x:"20%",y:"20",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"600px"),React.createElement("text",{x:"70%",y:"20",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"1200px"),React.createElement("text",{x:"-20",y:"-20%",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"20px"),React.createElement("text",{x:"-20",y:"-70%",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"50px")))}}function c(){return React.createElement($index,{label:"Proyección cerrada [ ]"},React.createElement($h3,null,"Proyección cerrada [ ]"),React.createElement($$h,null),React.createElement($CardF,null,"Los corchetes [ ] indican una proyección cerrada, lo que significa que la interpolación se limita al rango de anchos especificado, conservando los valores del extremo más cercano al ancho de la pantalla.",React.createElement("p",null,"En otras palabras, si el ancho de la pantalla está fuera del rango definido, el valor de la propiedad no cambiará más allá del valor del extremo más cercano. Es decir, si el ancho de la pantalla es menor que el valor mínimo, se utilizará el valor de ese extremo; si es mayor que el valor máximo, se utilizará el valor del otro extremo."),React.createElement("strong",null,"Sintáxis"),React.createElement($h,null),React.createElement($code,{style:{color:"khaki"},elevation:0},["600px<-x->1200px?{","   margin: [20px, 50px];","}"].join("\n")),React.createElement("center",null,React.createElement(e,null)),React.createElement($$h,null),"Esto significa que la interpolación del margen irá desde 20px a 50px conforme el ancho de la pantalla cambie de 600px a 1200px. Si la pantalla es más pequeña que 600px o más grande que 1200px, el valor de margin se mantendrá en 20px o 50px, respectivamente, dependiendo de cuál sea el valor más cercano."));function e(){return React.createElement("svg",{width:"350",height:"300",xmlns:"http://www.w3.org/2000/svg",style:{backgroundColor:"white",margin:"20px",filter:"invert(0.95)",borderRadius:"20px"}},React.createElement("g",{transform:"translate(40, 260)"},React.createElement("line",{x1:"-350",y1:"0",x2:"350",y2:"0",stroke:"black",strokeWidth:"2"}),React.createElement("line",{x1:"0",y1:"-300",x2:"0",y2:"300",stroke:"black",strokeWidth:"2"}),React.createElement("line",{x1:"20%",y1:"-300",x2:"20%",y2:"300",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"70%",y1:"-300",x2:"70%",y2:"300",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"-350",y1:"-20%",x2:"350",y2:"-20%",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"-350",y1:"-70%",x2:"350",y2:"-70%",stroke:"skyblue",strokeWidth:"2"}),React.createElement("line",{x1:"20%",y1:"-20%",x2:"70%",y2:"-70%",stroke:"red",strokeWidth:"3"}),React.createElement("line",{x1:"-350",y1:"-20%",x2:"20%",y2:"-20%",stroke:"magenta",strokeWidth:"3"}),React.createElement("line",{x1:"70%",y1:"-70%",x2:"350",y2:"-70%",stroke:"magenta",strokeWidth:"3"}),React.createElement("text",{x:"20%",y:"20",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"600px"),React.createElement("text",{x:"70%",y:"20",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"1200px"),React.createElement("text",{x:"-20",y:"-20%",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"20px"),React.createElement("text",{x:"-20",y:"-70%",fontSize:"12",fill:"black",textAnchor:"middle",fontWeight:"bold"},"50px")))}}}